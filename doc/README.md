# CPU arch

## Tomasulo algorithm

CPU执行过程分为四级：

1. 第一级取指令，每次取出2或4条指令。
2. 第二级译码，从`RegStat`中取出寄存器的状态。之后再逐条指令喷射。
3. 第三级执行，并将寄存器状态写回`RegStat`。
4. 第四级处理跳转指令，将指令重排序后输出。

### Fetch

为指令使用专用`cache`,让一次能取多条指令。由于分支的存在，需要先更新`pc`。

### Decode/Issue

发射阶段逐条指令发射，先更新运算器的`busy`状态，顺序发射，一旦发现没有足够的运算器，就直接`stall`。发射完之后还需要更新`RegStat`。

### Execute

执行运算器，值得注意的是`Load/Store`指令，也会想寄存器那样出现`RAW`,`WAW`,`WAR`等情况，所以每次执行要枚举其他的`LS`运算器。执行完后将状态发给广播站以及更新`RegStat`。广播站将会将会将状态广播给发射器。

## Branch prediction

~~分支处理的大致思路是这样，每次应保证只有一条条件跳转指令被发射出来，遇到条件跳转时如果还有条件条件跳转指令没执行，那么就`stall`。再译码阶段进行分支预测，同时CPU进入预测执行状态。~~

~~将`RegStat`复制一份为`RegStatBuffer`，之后将值写回`RegStat`时，如果发现这个值在两份`Stat`里面相同，说明是跳转前的指令，直接在两分里面写回。否则只写到`buffer`。当分支指令执行完，如果预测成功，切换`RegStat`到`buffer`(这里可能只需要打个标记即可),否则调整`pc`,直接从原来的`RegStat`继续执行即可。~~

~~除了条件跳转，还有直接跳转，**JAL**指令在译码阶段就直接跳转，而`JALR`选择是`stall`。~~

感觉上面的这个方法不是很优美，所以还是使用`ROB`吧。

首先条件跳转指令，为了避免考虑多重跳转，所以我设置跳转指令处理单元只有一个。当条件条件指令被发射时，CPU进入预测执行模式，指令运算完后先进入`ROB`。当这个条件指令运算完后，如果预测错了了，下一周期清空所有运算器，修改`if`的`pc`。否则直接将`ROB`的指令喷射。

在跳转指令处理单元装入了跳转指令后，将发射的指令打个标记，表示是预测的指令，在跳转指令出来的时候还需要把运算单元的标记清除。不过可能刚放出来又会放进去一个指令。对于`ROB`。因为如果两条指令写同一个寄存器一定是顺序执行完的，所以对于分支指令后的指令，store指令直接暂停流水线。其他指令除了写入regstat，还需要备份吗原来的值到`ROB`。注意`data`和`tag`都需要备份。

## Cache

